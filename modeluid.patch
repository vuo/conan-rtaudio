--- RtAudio.h.orig	2016-09-19 09:40:14.000000000 -0400
+++ RtAudio.h	2016-09-18 18:47:12.000000000 -0400
@@ -280,6 +280,7 @@ class RtAudio
   struct DeviceInfo {
     bool probed;                  /*!< true if the device capabilities were successfully probed. */
     std::string name;             /*!< Character string device identifier. */
+    std::string modelUid;         /*!< Unique, non-localized, system-independent identifier for this model of device. */
     unsigned int outputChannels;  /*!< Maximum output channels supported by device. */
     unsigned int inputChannels;   /*!< Maximum input channels supported by device. */
     unsigned int duplexChannels;  /*!< Maximum simultaneous input/output channels supported by device. */
--- RtAudio.cpp.orig	2017-05-22 19:34:25.000000000 -0400
+++ RtAudio.cpp	2017-05-22 19:39:36.000000000 -0400
@@ -668,6 +668,23 @@ RtAudio::DeviceInfo RtApiCore :: getDevi
   CFRelease( cfname );
   free(name);
 
+  property.mSelector = kAudioDevicePropertyModelUID;
+  result = AudioObjectGetPropertyData( id, &property, 0, NULL, &dataSize, &cfname );
+  if ( result != noErr )
+    // Instead of returning an error, just use an empty modelUid.
+    cfname = CFSTR("");
+
+  length = CFStringGetLength(cfname);
+  char *modelUid = (char *)malloc(length * 3 + 1);
+#if defined( UNICODE ) || defined( _UNICODE )
+  CFStringGetCString(cfname, modelUid, length * 3 + 1, kCFStringEncodingUTF8);
+#else
+  CFStringGetCString(cfname, modelUid, length * 3 + 1, CFStringGetSystemEncoding());
+#endif
+  info.modelUid = modelUid;
+  CFRelease( cfname );
+  free(modelUid);
+
   // Get the output stream "configuration".
   AudioBufferList	*bufferList = nil;
   property.mSelector = kAudioDevicePropertyStreamConfiguration;
